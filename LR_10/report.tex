\documentclass[a4paper,12pt]{article}

\input{preamble}

\begin{document}
	
\include{title}

\textbf{Цель работы}: приобрести навыки организации рекурсии в Lisp.\\

\textbf{Задачи работы}: изучить способы организации хвостовой, дополняемой, множественной, взаимной рекурсии и рекурсии более высокого порядка в Lisp.

\section*{Лабораторная работа 6}

\subsection*{Задание 7}

Пусть list-of-lists список, состоящий из списков. Написать функцию, которая вычисляет сумму длин всех элементов list-of-lists, т.е. например для аргумента ((1 2) (3 4)) -> 4.

\subsubsection*{С использованием функционалов:}
\begin{lstlisting}[caption=Функция вычисления суммарной длины списков]
(defun count-length (list-of-lists)
	(reduce #'+
		(mapcar #'(lambda (x)
				(cond
					(
						(atom x)
						1
					)
					(
						(count-length x)
					)
				)
			) list-of-lists
		)
	)
)
\end{lstlisting}
\textbf{list-of-lists} - входной список.

С помощью mapcar для каждого элемента проверяется, является ли он списком или атомом, если он является атомом, то его длина равна 1, иначе для него рекурсивно вызывается текущая функция. Затем с помощью reduce осуществляется суммирование длин элементов списка.

\subsubsection*{Хвостовая рекурсия:}
\begin{lstlisting}[caption=Функция-обертка для вычисления суммарной длины списков]
(defun count-length (lst)
	(count-length-helper lst 0)
)
\end{lstlisting}
\textbf{lst} - входной список.
\begin{lstlisting}[caption=Функция для вычисления суммарной длины списков]
 (defun count-length-helper (lst length)
	(cond	
		(
			(null lst) 
			length
		)
		(
			(listp (car lst)) 
			(count-length-helper 
				(cdr lst) 
				(count-length-helper (car lst) length)) 
			)
		(
			(count-length-helper (cdr lst) (+ length 1))
		)
	)
)
\end{lstlisting}
\textbf{lst} - входной список, \textbf{length} - длина списка.

Условием выхода из рекурсии является достижение конца списка(первый аргумент - nil) - возвращается второй аргумент, в котором накапливается суммарная длина списка. Если голова первого аргумента список, то осуществляется рекурсивный вызов текущей функции для хвоста первого аргумента и рекурсивного вызова, который осуществляется для головы первого аргумента и второго аргумента. Иначе осуществляется рекурсивный вызов текущей функции для хвоста списка и второго аргумента, увеличенного на 1.

\subsubsection*{Примеры работы:}
\begin{lstlisting}
> (count-length nil)
0
> (count-length '(1))
1
> (count-length '(1 2 3))
3
> (count-length '((1 2) (3 4)))
4
> (count-length '((1 2 (3) 4) 5 (6)))
6
\end{lstlisting}

\subsection*{Задание 8}

Написать рекурсивную версию (с именем rec-add) вычисления суммы чисел заданного списка.

\newpage

\subsubsection*{Множественная рекурсия:}
\begin{lstlisting}[caption=Функция вычисления суммы чисел списка]
(defun rec-add (lst)
	(cond
		(
			(numberp lst)
			lst
		)
		(
			(atom lst)
			0
		)
		(
			(+ 
				(rec-add (car lst))
				(rec-add (cdr lst))
			)
		)
	)
)
\end{lstlisting}
\textbf{lst} - входной список.

Условиями выхода из рекурсии являются:
\begin{itemize}
	\item нахождение элемента, являющегося числом - возвращается этот элемент;
	\item нахождение элемента, являющегося атомом - возвращается 0. 
\end{itemize}
Иначе осуществляются рекурсивные вызовы текущей функции для головы и хвоста аргумента, а результаты вызовов складываются и возвращаются.

\subsubsection*{Хвостовая рекурсия:}
\begin{lstlisting}[caption=Функция-обертка для вычисления суммы чисел списка]
(defun rec-add (lst)
	(rec-add-helper lst 0)
)
\end{lstlisting}
\textbf{lst} - входной список.
\begin{lstlisting}[caption=Функция вычисления суммы чисел списка]
(defun rec-add-helper (lst sum)
	(cond	
		(
			(null lst) 
			sum
		)
		(
			(listp (car lst)) 
			(rec-add-helper (cdr lst) (rec-add-helper (car lst) sum)) )
		(
			(numberp (car lst)) 
			(rec-add-helper	(cdr lst) (+ sum (car lst)))
		)
		(
			(rec-add-helper (cdr lst) sum)
		)
	)
)
\end{lstlisting}
\textbf{lst} - входной список, \textbf{sum} - сумма чисел списка.

Условием выхода из рекурсии является достижение конца списка (первый аргумент - nil) - возвращается второй аргумент, в котором накапливается сумма чисел списка. Иначе, если голова первого аргумента список, то осуществляется рекурсивный вызов текущей функции для хвоста первого аргумента и рекурсивного вызова, который осуществляется для головы первого аргумента и второго аргумента. Если голова первого аргумента - число, то осуществляется рекурсивный вызов текущей функции для хвоста списка и суммы второго аргумента и головы первого аргумента. Если голова первого аргумента не число и не список, то осуществляется рекурсивный вызов текущей функции для хвоста первого аргумента и второго аргумента.
\subsubsection*{Примеры работы:}
\begin{lstlisting}
> (rec-add '(1))
1
> (rec-add nil)
0
> (rec-add '(1 2 3))
6
> (rec-add '(1 2 (3 4) (5 (6))))
21
> (rec-add '(1 2 (a b (3)) nil (2 0)))
8
\end{lstlisting}

\subsection*{Задание 9}

Написать рекурсивную версию с именем rec-nth функции nth.
\begin{lstlisting}[caption=Рекурсивная версия функции nth]
(defun rec_nth (lst n)
	(cond 
		( 
			(null lst) 
			nil
		)
		(
			(= n 0)
			(car lst)
		)
		(
			(rec_nth (cdr lst) (- n 1))
		)
	)
)
\end{lstlisting}
\textbf{lst} - входной список, \textbf{n} - индекс элемента, который нужно получить (начиная с 0).

Условиями выхода из рекурсии являются:
\begin{itemize}
	\item достижение конца списка(первый аргумент функции - nil) - возвращается nil;
	\item нахождение искомого элемента списка (второй аргумент функции равен 0) - возвращается этот элемент. 
\end{itemize} 
Иначе осуществляется рекурсивный вызов текущей функции для хвоста первого аргумента и второго аргумента, уменьшенного на 1.

\subsubsection*{Примеры работы:}
\begin{lstlisting}
> (rec_nth nil 10)
NIL
> (rec_nth '(1) 0)
1
> (rec_nth '(1 (2 3) (4) 5 6) 1)
(2 3)
> (rec_nth '(1 2 3) 10)
NIL
\end{lstlisting}

\subsection*{Задание 10}

Написать рекурсивную функцию alloddr, которая возвращает t, когда все элементы списка нечетные.

\subsubsection*{Множественная рекурсия:}
\begin{lstlisting}[caption=Функция проверки на нечетность всех элементов списка]
(defun alloddr (lst)
	(cond
		(
			(or
				(null lst)
				(and (numberp lst)(oddp lst))
			)
		)
		(
			(atom lst)
			nil
		)
		(
			(and 
				(alloddr (car lst))
				(alloddr (cdr lst))
			)
		)
	)
)
\end{lstlisting}
\textbf{lst} - входной список.

Условиями выхода из рекурсии являются:
\begin{itemize}
	\item достижение конца списка(аргумент функции - nil) или нахождение нечетного числа - возвращается t;
	\item нахождение элемента, вялящегося атомом, не подходящим по первому условию - возвращается nil.
\end{itemize}
Иначе осуществляются рекурсивные вызовы текущей функции для головы и хвоста аргумента, а возвращается логическое умножение этих вызовов.

\subsubsection*{Хвостовая рекурсия:}
\begin{lstlisting}[caption=Функция-обертка проверки на нечетность всех элементов списка]
(defun alloddr (lst)
	(alloddr-helper lst t)
)
\end{lstlisting}
\textbf{lst} - входной список.
\begin{lstlisting}[caption=Функция проверки на нечетность всех элементов списка]
(defun alloddr-helper (lst isodd)
	(cond	
		(
			(or (null lst)(not isodd))
			isodd
		)
		(
			(listp (car lst))
			(alloddr-helper 
				(cdr lst) 
				(alloddr-helper (car lst) isodd)
			)
		)
		(
			(and 
				(numberp (car lst))
				(oddp (car lst))
			)
			(alloddr-helper (cdr lst) isodd)
		)
	)
)
\end{lstlisting}
\textbf{lst} - входной список, \textbf{isodd} - логическая переменная для определения, содержаться ли в списке только нечетные числа, или нет.

По умолчанию считается, что список состоит только из нечетных чисел, поэтому начальное значение \textbf{isodd} - t.
 
Условием выхода из рекурсии является достижение конца списка(первый аргумент - nil) или нахождение элемента, являющего не нечетным(второй аргумент - nil) - возвращается второй аргумент. Если голова первого аргумента список, то осуществляется рекурсивный вызов текущей функции для хвоста первого аргумента и рекурсивного вызова, который осуществляется для головы первого аргумента и второго аргумента. Иначе, если голова первого аргумента - нечетное число, то осуществляется рекурсивный вызов текущей функции для хвоста списка и второго аргумента.

\subsubsection*{Примеры работы:}
\begin{lstlisting}
> (alloddr nil)
T
> (alloddr '(1))
T
> (alloddr '(1 2))
NIL
> (alloddr '(1 3))
T
> (alloddr '(1 (3 (5) 7) 9))
T
> (alloddr '(1 (3 nil) 2))
NIL
\end{lstlisting}

\subsection*{Задание 11}

Написать рекурсивную функцию, относящуюся к хвостовой рекурсии с одним тестом завершения, которая возвращает последний элемент списка-аргумента.
\begin{lstlisting}[caption=Функция получения последнего элемента списка]
(defun get_last (lst)
	(cond 
		(
			(null (cdr lst))
			(car lst)
		)
		(
			(get_last (cdr lst))
		)
	)
)
\end{lstlisting}
\textbf{lst} - входной список.

Условием выхода из рекурсии является достижение конца списка (хвост аргумента функции - nil) - возвращается голова аргумента. Иначе осуществляется рекурсивный вызов текущей функции для хвоста аргумента.

\subsubsection*{Примеры работы:}
\begin{lstlisting}
> (get_last nil)
NIL
> (get_last '(1))
1
> (get_last '(1 2 3 4 5))
5
> (get_last '(1 2 (3 4) (5) 6 7))
7
> (get_last '(1 2 (3 4)))
(3 4)
\end{lstlisting}

\subsection*{Задание 12}

Написать рекурсивную функцию, относящуюся к дополняемой рекурсии с одним тестом завершения, которая вычисляет сумму всех чисел от 0 до n-ого аргумента функции. 
\begin{lstlisting}[caption=Функция вычисления суммы элементов от 0 до n-го]
(defun sum_to_n (lst n)
	(cond
		(
			(or (= n 0)(null lst))
			0
		)
		(
			(+ 
				(car lst)
				(sum_to_n (cdr lst) (- n 1))
			)
		)
	)
)	
\end{lstlisting}
\textbf{lst} - входной список, \textbf{n} - индекс элемента, до которого нужно производить сложение.

Условием выхода из рекурсии является достижение конца списка(первый аргумент функции - nil) или достижение нужного элемента(второй аргумент функции - 0) - возвращается 0. Иначе осуществляется рекурсивный вызов текущей функции для хвоста первого аргумента и второго аргумента, уменьшенного на 1, и возвращается сумма результата рекурсивного вызова и головы первого аргумента.
\subsubsection*{Примеры работы:}
\begin{lstlisting}
> (sum_to_n nil 1)
0
> (sum_to_n '(1) 1)
1
> (sum_to_n '(1 2 3 4 5 6) 3)
6
\end{lstlisting}

\subsection*{Задание 13}

Написать рекурсивную функцию, которая возвращает последнее нечетное число из числового списка, возможно создавая некоторые вспомогательные функции.

\begin{lstlisting}[caption=Функция-обертка для получения последнего нечетного числа]
(defun get_last_odd (lst)
	(get_odd lst nil)
)
\end{lstlisting}
\textbf{lst} - входной список.
\begin{lstlisting}[caption=Функция получения последнего нечетного числа]
(defun get_odd (lst num)
	(cond	
		(
			(null lst) 
			num
		)
		(
			(oddp (car lst))
			(get_odd (cdr lst) (car lst))
		)
		(
			(get_odd (cdr lst) num)
		)
	)
)
\end{lstlisting}
\textbf{lst} - входной список, \textbf{num} - последнее найденное нечетное число.

Условием выхода из рекурсии является достижение конца списка(первый аргумент - nil) - возвращается второй аргумент. Иначе осуществляется проверка на нечетность головы первого аргумента, если он нечетный, то осуществляется рекурсивный вызов текущей функции для хвоста первого аргумента и головы первого аргумента, если четный - осуществляется рекурсивный вызов для хвоста первого аргумента и второго аргумента.
\subsubsection*{Примеры работы:}
\begin{lstlisting}
> (get_last_odd nil)
NIL
> (get_last_odd '(1))
1
> (get_last_odd '(1 2 3))
3
> (get_last_odd '(1 2 3 4 5 6))
5
\end{lstlisting}

\subsection*{Задание 14}

Используя cons-дополняемую рекурсию с одним тестом завершения, написать функцию которая получает как аргумент список чисел, а возвращает список квадратов этих чисел в том же порядке. 
\begin{lstlisting}[caption=Функция получения квадратов чисел из списка]
(defun get_squares(lst)
	(cond
		(
			(null lst)
			nil
		)
		(
			(cons  
				(* (car lst)(car lst)) 
				(get_squares (cdr lst))
			)
		)
	)
)
\end{lstlisting}
\textbf{lst} - входной список.

Условием выхода из рекурсии является достижение конца списка (аргумент -  nil) - возвращается nil. Иначе осуществляется рекурсивный вызов текущей функции для хвоста аргумента, и возвращатеся списочная ячейка, указатель головы которой указывает на голову аргумента, умноженную на саму себя, а указатель хвоста - на результат рекурсивного вызова.

\newpage

\subsubsection*{Примеры работы:}
\begin{lstlisting}
> (get_squares nil)
NIL
> (get_squares '(1))
(1)
> (get_squares '(1 2))
(1 4)
> (get_squares '(1 2 3 4 5))
(1 4 9 16 25)
\end{lstlisting}

\subsection*{Задание 15}

Написать функцию с именем select-odd, которая из заданного списка выбирает все нечетные числа.

\subsubsection*{С использованием функционалов:}
\begin{lstlisting}[caption=Функция получения всех нечетных чисел из списка]
(defun select-odd (lst)
	(mapcan #'(lambda (x)
			(cond 
				(
					(and (numberp x)(oddp x))
					(cons x nil)
				)
				(
					(listp x)
					(select-odd x)
				)
			)
		) lst
	)
)
\end{lstlisting}
\textbf{lst} - входной список.

С помощью mapcan осуществляется проверка типа каждого элемента:
\begin{itemize}
	\item если он является нечетным числом, то возвращается списочная ячейка, указатель головы которой указывает на элемент, а хвоста - на nil;
	\item если он является списком, то для него осуществляется рекурсивный вызов текущей функции;
	\item во всех иных случаях возвращается nil.
\end{itemize}

\subsubsection*{Хвостовая рекурсия:}
\begin{lstlisting}[caption=Функция-обертка получения всех нечетных чисел из списка]
(defun select-odd (lst)
	(reverse (select-odd-helper lst nil))
)
\end{lstlisting}
\textbf{lst} - входной список.
\begin{lstlisting}[caption=Функция получения всех нечетных чисел из списка]
(defun select-odd-helper (lst res)
	(cond
		(
			(null lst)
			res
		)
		(
			(listp (car lst))
			(select-odd-helper 
				(cdr lst) 
				(select-odd-helper (car lst) res))
		)
		(
			(and 
				(numberp (car lst))
				(oddp (car lst))
			)
			(select-odd-helper (cdr lst) (cons (car lst) res))
		)
		(
			(select-odd-helper (cdr lst) res)
		)
	)
)
\end{lstlisting}
\textbf{lst} - входной список, \textbf{res} - результирующий список нечетных чисел.

Условием выхода из рекурсии является достижение конца списка(первый аргумент - nil) - возвращается второй аргумент. Если голова первого аргумента список, то осуществляется рекурсивный вызов текущей функции для хвоста первого аргумента и рекурсивного вызова, который осуществляется для головы первого аргумента и второго аргумента. Если голова первого аргумента - нечетное число, то осуществляется рекурсивный вызов текущей функции для хвоста списка и списка, указатель на голову которого указывает на голову первого аргумента, а указатель на хвост - на второй аргумент. Иначе осуществляется рекурсивный вызов текущей функции для хвоста списка и второго аргумента.

При данной реализации результирующий список оказывается перевернутым, поэтому к нему применяется функция reverse.

\subsubsection*{Примеры работы:}
\begin{lstlisting}
> (select-odd nil)
NIL
> (select-odd '(1))
(1)
> (select-odd '(1 2 3 4 5))
(1 3 5)
> (select-odd '((1 2 (3) 4) a (5 (7))))
(1 3 5 7)
\end{lstlisting}

\section*{Теоретические вопросы}
\subsection*{Способы организации повторных вычислений в Lisp}

Для организации многократных вычислений в Lisp могут быть использованы функционалы - функции, которые в качестве своего аргумента принимают функциональный объект — функцию, имеющую имя (глобально определенную функцию), или функцию, не имеющую имени (локально определенную функцию).

Также для организации многократных вычислений в Lisp может быть использована рекурсия. Рекурсия — это ссылка на определяемый объект во время его определения. 

\subsection*{Что такое рекурсия?Классификация рекурсивных функций в Lisp}

Рекурсия — это ссылка на определяемый объект во время его определения. 
В LISP существует классификация рекурсивных функций:
\begin{itemize}
	\item простая рекурсия - один рекурсивный вызов в теле
	\item рекурсия первого порядка - рекурсивный вызов встречается несколько раз
	\item взаимная рекурсия - используется несколько функций, рекурсивно вызывающих друг друга.
\end{itemize}

\subsection*{Различные способы организации рекурсивных функций и порядок их реализации}

Способы организации рекурсивных функций:
\begin{itemize}
	\item Хвостовая рекурсия
	
	Результат формируется не на выходе из рекурсии, а на входе в рекурсию, все действия выполняются до ухода на следующий шаг рекурсии.
	\begin{lstlisting}
	(defun fun (x)
	(cond	(end_test1	end_value1)
	...
	(end_testN	end_valueN)
	( (fun reduced_x) )
	) )
	\end{lstlisting}
	\item Рекурсия по нескольким параметрам
	\begin{lstlisting}
	(defun fun (n x)
	(cond	(end_test	end_value)
	( t	(fun (reduced_n) (reduced_x))
	) )
	\end{lstlisting}
	\item Дополняемая рекурсия
	
	При обращении к рекурсивной функции используется дополнительная функция не в аргументе вызова, а вне его.
	\begin{lstlisting}
	(defun fun (x)
	(cond	(test end_value)
	(t (add_fun	add_value	(fun reduced_x)) )
	))
	\end{lstlisting}
	
	\item Множественная рекурсия
	
	На одной ветке происходит сразу несколько рекурсивных вызовов. Количество условий выхода также может зависеть от задачи.
	\begin{lstlisting}
	(defun fun (x)
	(cond	(test end_val)
	( t (combine	(fun changed1_x)
	(fun changed2_x))
	)
	))
	\end{lstlisting}
	
\end{itemize}

\subsection*{Способы повышения эффективности реализации рекурсии}
	
	Рекомендуется организовывать и отлаживать реализацию отдельных подзадач исходной задачи, обращая внимание на эффективность реализации и качество работы, а потом, при необходимости, встраивать эти функции в более крупные, возможно в виде  лямбда-выражений.
	
	Для повышения эффективности рекурсии необходимо правильно организовывать условия выхода из нее. Основное правило: при построении условного выражения первое условие  - это всегда выход из рекурсии, но если условий выхода несколько, то надо думать о порядке их следования. Некачественный выход из рекурсии может привести к переполнению памяти из-за "лишних" рекурсивных вызовов. Кроме того возможна потеря аргумента - кажется что функция возвращает результат и он используется, но на деле результат теряется и ответ неверен.
	
	В целях повышения эффективности рекурсивных функций рекомендуется формировать результат не на выходе из рекурсии, а на входе в рекурсию, все действия выполняя до ухода на следующий шаг рекурсии.
	
\end{document}