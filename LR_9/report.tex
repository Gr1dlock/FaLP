\documentclass[a4paper,12pt]{article}

\input{preamble}

\begin{document}
	
\include{title}

\textbf{Цель работы}: приобрести навыки использования функционалов и рекурсии.\\

\textbf{Задачи работы}: изучить работу и методы использования отображающих функционалов: mapcar, maplist, reduce и др., изучить способы организации хвостовой рекурсии, сравнить эффективность.

\section*{Лабораторная работа 5}

\subsection*{Задание 2}

Написать предикат set-equal, который возвращает t, если два его множества-аргумента содержат одни и те же элементы, порядок которых не имеет значения.

\subsubsection*{Реализация с помощью функционалов:}
\begin{lstlisting}[caption=Функция проверки эквивалентности двух множеств]
(defun check-sets-equal (set1 set2)
	(cond 
		(
			(and
				(reduce #'(lambda (x y) (and x y))
					(mapcar #'(lambda (x) 
							(mapcan #'(lambda (y)
									(cond 
										(
											(equal x y)
											(cons y nil)
										)
									)
								) set2
							)
						) set1
					)
				)
				(reduce #'(lambda (x y) (and x y))
					(mapcar #'(lambda (x)
							(mapcan #'(lambda (y)
									(cond 
										(
											(equal x y)
											(cons y nil)
										)
									)
								) set1
							)
						) set2
					)
				)
			)
			T
		)
	)
)
\end{lstlisting}

\textbf{set1} и \textbf{set2} - списки-множества.

С помощью mapcan идет проверка на вхождение элемента во множество, возвращается список из элементов другого множества, равных текущему элементу, или nil, если таких нет. С помощью mapcar определяется факт вхождения каждого из элементов одного множества в другое. Затем с помощью reduce осуществляется проверка на то, что каждый элемент текущего множества есть в другом множестве. Проверку на то, что множество является подмножеством другого множества необходимо произвести для каждого из двух переданных на вход функции множеств.

\subsubsection*{Реализация с помощью рекурсии:}
\begin{lstlisting}[caption=Функция проверки эквивалентности двух множеств]
(defun check-sets-equal (set1 set2)
	(and
		(is-subset set1 set2)
		(is-subset set2 set1)
	)
)
\end{lstlisting}
\textbf{set1} и \textbf{set2} - списки-множества.
\begin{lstlisting}[caption=Функция проверки вхождения подмножества во множество]
(defun is-subset (set subset)
	(cond
		(
			(null subset)
		)
		(
			(and 
				(contains set (car subset))
				(is-subset set (cdr subset))
			)
		)
	)
)
\end{lstlisting}
\textbf{set} и \textbf{subset} - первое множество и второе множество, для которого проверяется является ли оно подмножеством первого множества.

\newpage

\begin{lstlisting}[caption=Функция проверки вхождения элемента в список]
(defun contains (lst element)
	(cond
		(
			(null lst)
			nil
		)
		(
			(equal (car lst) element)
		)
		(
			(contains (cdr lst) element)
		)
	)
)
\end{lstlisting}
\textbf{lst} - список,  \textbf{element} - элемент, для которого проверяется, входит ли он во  список-аргумент.

Рекурсивная реализация является более эффективной по памяти, так как в процессе вычислений не выделяет никаких списочных ячеек. Также она является более эффективной по времени, так как прерывает вычисления, как только обнаруживается, что элемент одного множества не входит в другое.

\subsubsection*{Примеры работы:}
\begin{lstlisting}
> (check-sets-equal '(1 3 2) '(3 2 1))
T
> (check-sets-equal '(1 2) '(3 2 1))
NIL
> (check-sets-equal '(1) '(1))
T
> (check-sets-equal '(E H H H) '(H E))
T
\end{lstlisting}

\subsection*{Задание 3}

Напишите необходимые функции, которые обрабатывают таблицу из точечных пар: (страна . столица), и возвращают по стране - столицу, а по столице - страну.

\subsubsection*{Реализация с помощью функционалов:}
\begin{lstlisting}[caption=Функция поиска в списке точечных пар]
(defun find_in_pairs (lst name)
	(reduce #'(lambda (x y)(or x y))
		(mapcar #'(lambda (x)
				(cond
					(
						(equal (car x) name)
						(cdr x)
					)
					(
						(equal (cdr x) name)
						(car x)
					)
				)
			) lst
		)
	)
)
\end{lstlisting}
\textbf{lst} - список точечных пар,  \textbf{element} - элемент, для которого проверяется, входит ли он в одну из точечных пар списка-аргумента.

С помощью mapcar осуществляется перебор всех точечных пар, возвращается список, состоящий из nil-ов и искомого элемента. Затем с помощью reduce возвращается искомый элемент.

\subsubsection*{Реализация с помощью рекурсии:}
\begin{lstlisting}[caption=Функция поиска в списке точечных пар]
(defun find_in_pairs (lst name)
	(cond
		(
			(null lst)
			nil
		)
		(
			(equal (caar lst) name)
			(cdar lst)
		)
		(
			(equal (cdar lst) name)
			(caar lst)
		)
		(
			(find_in_pairs (cdr lst) name)
		)
	)
)
\end{lstlisting}
\textbf{lst} - список точечных пар,  \textbf{element} - элемент, для которого проверяется, входит ли он в одну из точечных пар списка-аргумента.

Рекурсивная реализация является более эффективной по времени, так как если искомый элемент найден, то он сразу возвращается.

\newpage

\subsubsection*{Примеры работы:}
\begin{lstlisting}
> (find_in_pairs '((moscow . russia) (london . england) (washington . usa)) 'moscow)
RUSSIA
> (find_in_pairs '((moscow . russia) (london . england) (washington . usa)) 'russia)
MOSCOW
> (find_in_pairs '((moscow . russia) (london . england) (washington . usa)) 'kiev)
NIL
\end{lstlisting}

\subsection*{Задание 7}

Напишите функцию, которая умножает на заданное число-аргумент все числа из заданного списка-аргумента, когда
\begin{enumerate}
	\item[а)] все элементы списка - числа,
	\item[б)] элементы списка - любые объекты.
\end{enumerate}

\subsubsection*{Реализация с помощью функционалов:}
\begin{lstlisting}[caption=Функция умножения для списка из чисел]
(defun mult_num (lst num)
	(mapcar 
		#'(lambda (el) (* el num))
		lst
	)
)
\end{lstlisting}
\textbf{lst} - список чисел,  \textbf{num} - число, на которое умножаются все числа в списке-аргументе.

\subsubsection*{Реализация с помощью рекурсии:}
\begin{lstlisting}[caption=Функция умножения для списка из чисел]
(defun mult_num (lst num)
	(cond
		(
			(null lst)
			nil
		)
		(
			(cons 
				(* (car lst) num)
				(mult_num (cdr lst) num)
			)
		)
	)
)
\end{lstlisting}
\textbf{lst} - список чисел,  \textbf{num} - число, на которое умножаются все числа в списке-аргументе.

В обоих реализациях осуществляется проход по всему списку, умножение каждого элемента на число и создание списочной ячейки под результат умножения.

\subsubsection*{Реализация с помощью функционалов и рекурсии:}
\begin{lstlisting}[caption=Функция умножения для списка из любых объектов]
(defun mult_all (lst k)
	(mapcar #'(lambda (el)
			(cond
				(
					(numberp el)
					(* el k)
				)
				(
					(atom el)
					el
				)
				(
					(mult_all el k)
				)
			)
		) lst
	)
)
\end{lstlisting}
\textbf{lst} - список,  \textbf{k} - число, на которое умножаются все числа в списке-аргументе.

\subsubsection*{Реализация с помощью рекурсии:}
\begin{lstlisting}[caption=Функция умножения для списка из любых объектов]
(defun mult_all (lst k)
	(cond
		(
			(null lst)
			nil
		)
		(
			(numberp lst)
			(* lst k)
		)
		(
			(atom lst)
			lst
		)
		(
			(cons
				(mult_all (car lst) k)
				(mult_all (cdr lst) k)
			)
		)
	)
)
\end{lstlisting}
\textbf{lst} - список,  \textbf{k} - число, на которое умножаются все числа в списке-аргументе.

В обоих реализациях осуществляется проход по всему списку, проверка типа каждого элемента: 
\begin{itemize}
	\item если он является числом, то производится умножение на число-аргумент функции и выделение списочной ячейки под результат умножения; 
	\item если он является атомом, то под него выделяется списочная ячейка;
	\item если он является списком, то к нему рекурсивно применяется текущая функция.
\end{itemize}

Реализации являются одинаково эффективными, так как и реализация с помощью функционалов обходит список на всех уровнях и выделяет под каждый элемент списочную ячейку, и реализация с помощью рекурсии.

\subsubsection*{Примеры работы:}
\begin{lstlisting}
> (mult_num nil 1)
NIL
> (mult_num '(1) 3)
(3)
> (mult_num '(1 2 3 4 5) 3)
(3 6 9 12 15)
> (mult_all nil 2)
NIL
> (mult_all '(1) 2)
(2)
> (mult_all '(1 2 3) 3)
(3 6 9)
> (mult_all '((1 2) 3 (4 (5))) 3)
((3 6) 9 (12 (15)))
> (mult_all '(1 2 (a)) 3)
(3 6 (A))
\end{lstlisting}

\section*{Лабораторная работа 6}

\subsection*{Задание 2}

Напишите функцию, которая уменьшает на 10 все числа из списка
 аргумента этой функции.

\subsubsection*{Реализация с помощью функционалов и рекурсии:}
\begin{lstlisting}[caption=Функция уменьшения всех чисел смиска на 10]
(defun dec_all (lst)
	(mapcar #'(lambda (el)
		(cond
			(
				(numberp el)
				(- el 10)
			)
			(
				(atom el)
				el
			)
			(
				(dec_all el)
			)
			)
		) lst
	)
)
\end{lstlisting}
\textbf{lst} - список.

\subsubsection*{Реализация с помощью рекурсии:}
\begin{lstlisting}[caption=Функция уменьшения всех чисел смиска на 10]
(defun dec_all (lst)
	(cond
		(
			(null lst)
			nil
		)
		(
			(numberp lst)
			(- lst 10)
		)
		(
			(atom lst)
			lst
		)
		(
			(cons
				(dec_all (car lst))
				(dec_all (cdr lst))
			)
		)
	)
)
\end{lstlisting}
\textbf{lst} - список.

В обоих реализациях осуществляется проход по всему списку, проверка типа каждого элемента: 
\begin{itemize}
	\item если он является числом, то из него вычитается 10 и выделяется списочная ячейка; 
	\item если он является атомом, то под него выделяется списочная ячейка;
	\item если он является списком, то к нему рекурсивно применяется текущая функция.
\end{itemize}

Реализации являются одинаково эффективными, так как и реализация с помощью функционалов обходит список на всех уровнях и выделяет под каждый элемент списочную ячейку, и реализация с помощью рекурсии.

\subsubsection*{Примеры работы:}
\begin{lstlisting}
> (dec_all nil)
NIL
> (dec_all '(1 2 3 4 5))
(-9 -8 -7 -6 -5)
> (dec_all '(1 (2 3 (4)) (5)))
(-9 (-8 -7 (-6)) (-5))
> (dec_all '(1 (s t (4)) nil  (5)))
(-9 (S T (-6)) NIL (-5))
\end{lstlisting}

\subsection*{Задание 3}

Написать функцию, которая возвращает первый аргумент списка-аргумента, который сам является непустым списком.

\subsubsection*{Реализация с помощью функционалов:}
\begin{lstlisting}[caption=Функция поиска первого непустого списка]
(defun get_first_list (lst)
	(car 
		(mapcan #'(lambda (x)
				(cond
					(
						(and	
							(listp x)
							(not (null x))
						)
						(cons x nil)
					)
				)
			) lst
		)
	)
)
\end{lstlisting}
\textbf{lst} - список.

С помощью mapcan осуществляется перебор всех элементов списка и формируется список из непустых списков исходного списка, а затем с помощью car возвращается первый из них.

\subsubsection*{Реализация с помощью рекурсии:}
\begin{lstlisting}[caption=Функция поиска первого непустого списка]
(defun get_first_list (lst)
	(cond	
		(
			(and	
				(listp (car lst))
				(not (null (car lst)))
			)
			(car lst)
		)
		(
			(get_first_list (cdr lst))
		)
	)
)
\end{lstlisting}
\textbf{lst} - список.

Реализация с помощью рекурсии эффективнее и по памяти, и по скорости, так как не создает вспомогательных списков и возвращает непустой список сразу же, как он встретится.

\subsubsection*{Примеры работы:}
\begin{lstlisting}
> (get_first_list '(1 2 (3) (4 5 (6))))
(3)
> (get_first_list '(((1 2) 3) 4 5))
((1 2) 3)
> (get_first_list '(nil 2 (nil (5)) 6))
(NIL (5))
\end{lstlisting}

\subsection*{Задание 4}

Написать функцию, которая выбирает из заданного списка только числа между двумя заданными границами.

\subsubsection*{Реализация с помощью функционалов и рекурсии:}
\begin{lstlisting}[caption=Функция выбора чисел между указанными границами]
(defun select_between (lst a b)
	(mapcan	#'(lambda (x)
			(cond	
				(
					(and
						(numberp x) 
						(or 
							(and (>= x a) (<= x b)) 
							(and (<= x a) (>= x b))
						)
					)
					(cons x nil)
				)
				(
					(listp x) 
					(select_between x a b)
				)
			)
		) lst
	)
)
\end{lstlisting}
\textbf{lst} - список, \textbf{a}, \textbf{b} - числа-границы, между котороыми должны быть расположены искомые числа списка-аргумента.

\subsubsection*{Реализация с помощью рекурсии:}
\begin{lstlisting}[caption=Функция выбора чисел между указанными границами]
(defun select_between (lst a b)
	(cond 
		(
			(null lst)
			nil
		)
		(
			(and 
				(numberp lst)
				(or 
					(and (>= lst a) (<= lst b)) 
					(and (<= lst a) (>= lst b))
				)
			)
			(cons lst nil)
		)
		(
			(listp lst)
			(nconc 
				(select_between (car lst) a b)
				(select_between (cdr lst) a b)
			)
		)
	)
)
\end{lstlisting}
\textbf{lst} - список, \textbf{a}, \textbf{b} - числа-границы, между котороыми должны быть расположены искомые числа списка-аргумента.

В обоих реализациях осуществляется обход всего списка, если встреченный элемент число и он находится между заданными границами, то под него выделяется списочная ячейка, если элемент список, то к нему рекурсивно применяется текущая функция.

Реализации являются одинаково эффективными по памяти и по времени, так как в обоих осуществляется обход списка на всех уровнях и выделение списочных ячеек под необходимые элементы.

\subsubsection*{Примеры работы:}
\begin{lstlisting}
> (select_between '(1 2 3 4 5 6 7) 3 5)
(3 4 5)
> (select_between '(1 2 (3) (6 (7 8) 2) 9 5) 2 6)
(2 3 6 2 5)
> (select_between '(1 2 (3) (6 (7 8) 2) 9 5) 6 2)
(2 3 6 2 5)
> (select_between nil 1 2)
NIL
\end{lstlisting}

\subsection*{Задание 5}

Написать функцию, вычисляющую декартово произведение двух своих списков-аргументов.

\subsubsection*{Реализация с помощью функционалов:}
\begin{lstlisting}[caption=Функция вычисления декартова произведения]
(defun decart (set1 set2)
	(mapcan #'(lambda (x)
			(mapcar #'(lambda (y) 
				(cons x (cons y nil))
				) set2
			)
		) set1
	)
)
\end{lstlisting}
\textbf{set1} и \textbf{set2} - списки-множества.

С помощью mapcar получается декартово произведение одного элемента первого множества на второе множество, с помощью mapcan получается декартово произведение всех элементов первого множества на второе.

\subsubsection*{Реализация с помощью рекурсии:}
\begin{lstlisting}[caption=Функция вычисления декартова произведения]
(defun decart (set1 set2)
	(cond
		(
			(null set1)
			nil
		)
		(
			(nconc 
				(decart_element set2 (car set1))
				(decart (cdr set1) set2)
			)
		)
	)
)
\end{lstlisting}
\textbf{set1} и \textbf{set2} - списки-множества.
\begin{lstlisting}[caption=Функция декартова произведения одного элемента на множество]
(defun decart_element (set el)
	(cond 
		(
			(null set)
			nil
		)
		(
			(cons 
				(cons el (cons (car set) nil))
				(decart_element (cdr set) el)
			)
		)
	)
)
\end{lstlisting}
\textbf{set} - список-множество, \textbf{el} - элемент, для которого ищется декартово произведение со списком-аргументом.

Реализации одинаково эффективны по памяти и по скорости, так как в обоих реализациях для каждого элемента первого множества вычисляется его декартово произведение на второе множество, а затем все полученные множества объединяются в одно.

\newpage
\subsubsection*{Примеры работы:}
\begin{lstlisting}
> (decart '(1 2) '(a b c))
((1 A) (1 B) (1 C) (2 A) (2 B) (2 C))
> (decart '(1) '(A))
((1 A))
> (decart '(1) nil)
NIL
\end{lstlisting}

\subsection*{Задание 6}

Почему так реализовано reduce, в чем причина?
\begin{lstlisting}
(reduce #'+ ()) -> 0
\end{lstlisting}

Причина в том, что reduce должен корректно обрабатывать поданный ему список любого размера, поэтому когда список пуст и аргумент :initial-value не задан,  возвращается значение функции-аргумента, которую вызвали без аргументов, а если аргумент :initial-value задан, то возвращается его значение.

\section*{Теоретические вопросы}
\subsection*{Способы организации повторных вычислений в Lisp}

Для организации многократных вычислений в Lisp могут быть использованы функционалы - функции, которые в качестве своего аргумента принимают функциональный объект — функцию, имеющую имя (глобально определенную функцию), или функцию, не имеющую имени (локально определенную функцию).

Также для организации многократных вычислений в Lisp может быть использована рекурсия. Рекурсия — это ссылка на определяемый объект во время его определения. 

\subsection*{Различные способы использования функционалов,}

При использовании функционального объекта должно быть использовано замыкание контекста функции, которым обеспечивается связывание свободных переменных со значениями. В Lisp используются 
\begin{itemize}
	\item применяющие функционалы (apply, funcall);
	\item отобращающие функционалы (mapcar, maplist, mapcan, mapcon);
	\item функционалы, являющиеся предикатами;
	\item функционалы, использующие предикаты в качестве функционального объекта (remove-if, delete-if, remove-if-not, delete-if-not).
\end{itemize} 

\subsection*{Что такое рекурсия? Способы организации рекурсивных функций}

Рекурсия — это ссылка на определяемый объект во время его определения.
Способы организации рекурсивных функций:
\begin{itemize}
	\item Хвостовая рекурсия
	
	Результат формируется не на выходе из рекурсии, а на входе в рекурсию, все действия выполняются до ухода на следующий шаг рекурсии.
	\begin{lstlisting}
	(defun fun (x)
	(cond	(end_test1	end_value1)
	...
	(end_testN	end_valueN)
	( (fun reduced_x) )
	) )
	\end{lstlisting}
	 \item Рекурсия по нескольким параметрам
	 \begin{lstlisting}
	 (defun fun (n x)
	 (cond	(end_test	end_value)
	 ( t	(fun (reduced_n) (reduced_x))
	 ) )
	 \end{lstlisting}
	 \item Дополняемая рекурсия
	 
	  При обращении к рекурсивной функции используется дополнительная функция не в аргументе вызова, а вне его.
	  \begin{lstlisting}
	  (defun fun (x)
	  (cond	(test end_value)
	  (t (add_fun	add_value	(fun reduced_x)) )
	  ))
	 \end{lstlisting}
	 
	 \item Множественная рекурсия
	 
	 На одной ветке происходит сразу несколько рекурсивных вызовов. Количество условий выхода также может зависеть от задачи.
	 \begin{lstlisting}
	 (defun fun (x)
	 (cond	(test end_val)
	 ( t (combine	(fun changed1_x)
	 (fun changed2_x))
	 )
	 ))
	 \end{lstlisting}
\end{itemize}

\subsection*{Способы повышения эффективности реализации рекурсии}

Рекомендуется организовывать и отлаживать реализацию отдельных подзадач исходной задачи, обращая внимание на эффективность реализации и качество работы, а потом, при необходимости, встраивать эти функции в более крупные, возможно в виде  лямбда-выражений.

Для повышения эффективности рекурсии необходимо правильно организовавывать условия выхода из нее. Основное правило: при построении условного выражения первое условие  - это всегда выход из рекурсии, но если условий выхода несколько, то надо думать о порядке их следования. Некачественный выход из рекурсии может привести к переполнению памяти из-за "лишних" рекурсивных вызовов. Кроме того возможна потеря аргумента - кажется что функция возвращает результат и он используется, но на деле результат теряется и ответ неверен.

В целях повышения эффективности рекурсивных функций рекомендуется формировать результат не на выходе из рекурсии, а на входе в рекурсию, все действия выполняя до ухода на следующий шаг рекурсии.
\end{document}