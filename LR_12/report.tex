\documentclass[a4paper,12pt]{article}

\input{preamble}

\begin{document}
	
\include{title}

\textbf{Цель работы}: познакомиться со структурой, принципами оформления и логикой выполнения программы на Prolog.\\

\textbf{Задачи работы}: приобрести навыки декларативного описания предметной области с использованием фактов и правил.
Изучить способы использования фактов и правил в программе на Prolog, принципы  и правила сопоставления и отождествления, принцип унификации.

\section*{Теория}

\subsection*{Программа на Prolog}

Программа на Prolog представляет собой набор фактов и правил, обеспечивающих получение заключений на основе этих утверждений. Программа содержит базу знаний и вопрос. База знаний содержит истинные значения, используя которые программа выдает ответ на вопрос. 

Основным элементом языка является терм. Терм – это:
\begin{enumerate}
	\item Константа: 
	\begin{itemize}
		\item Число (целое, вещественное),
		\item Символьный атом (комбинация символов латинского алфавита, цифр и символа подчеркивания, начинающаяся со строчной буквы),
		\item Строка: последовательность символов, заключенных в кавычки.
	\end{itemize}
	\item Переменная:
	\begin{itemize}
		\item Именованная – обозначается комбинацией символов латинского алфавита, цифр и символа подчеркивания, начинающейся с прописной буквы или символа подчеркивания,
		\item Анонимная  - обозначается символом подчеркивания
	\end{itemize}
	\item Составной терм:
		Это средство организации группы отдельных элементов знаний в единый  объект,  синтаксически представляется: f(t1, t2, …,tm), где f -  функтор (отношение между объектами), t1, t2, …,tm – термы, в том  числе  и составные.
\end{enumerate}

База знаний состоит из предложений. Каждое предложение заканчивается точкой. Предложения бывают двух видов: факты и правила. Правило имеет вид: A :- B1,... , Bn. 
A называется заголовком правила, а B1,..., Bn – телом правила.
Факт – это частный случай правила, в котором отсутствует тело. Заголовок содержит отдельное знание о предметной области (составной терм), а тело содержит условия истинности этого знания. Заголовок правила синтаксически это составной терм. Тело правила может представлять собой один терм или быть последовательностью термов (конъюнкцией или дизъюнкцией). Правило называют условной истиной, а факт – безусловной.

Вопрос состоит только из тела – составного терма (или нескольких составных термов). Вопросы используются для выяснения выполнимости некоторого отношения между описанными в программе объектами. Система рассматривает вопрос как цель, к которой (к истинности которой) надо стремиться. Ответ на вопрос может оказаться логически положительным или отрицательным, в зависимости от того, может ли быть достигнута соответствующая цель.

\subsection*{Назначение и использование переменных}

Факты, правила, и вопросы могут содержать переменные. Именованные переменные уникальны в рамках предложения, а анонимная переменная – любая уникальна. В разных предложениях может использоваться одно имя переменной для обозначения разных объектов.
 В процессе выполнения программы переменные могут связываться с различными объектами – конкретизироваться. Это относится только к именованным переменным. Анонимные переменные не могут быть связаны со значением.

Также поддерживается механизм деструктивной конкретизации переменной. Т.е. используется идея реконкретизации переменной путем «отката» вычислительного процесса и отказа от выполненной ранее конкретизации. Это реализовано для возможности поиска нового значения для именованной переменной.

\subsection*{Структура программы}

Программа на Prolog состоит из следующих разделов:
\begin{itemize}
	\item директивы компилятора — зарезервированные символьные константы,
	\item CONSTANTS — раздел описания констант,
	\item DOMAINS — раздел описания доменов,
	\item DATABASE — раздел описания предикатов внутренней базы данных,
	\item PREDICATES — раздел описания предикатов,
	\item CLAUSES — раздел описания предложений базы знаний,
	\item GOAL — раздел описания внутренней цели (вопроса).
В программе не обязательно должны быть все разделы.
\end{itemize}

\subsection*{Формирование результата}

Ответ на поставленный вопрос система дает в логической форме - «Да» или «Нет». Цель системы состоит в том, чтобы на поставленный вопрос найти возможность, исходя из базы знаний, ответить «Да». Вариантов ответить «Да» на поставленный вопрос может быть несколько. В нашем случае система настроена в режим получения всех возможных вариантов ответа.

Поиск содержательного ответа на поставленный вопрос, с помощью имеющейся базы знаний, фактически заключается в поиске нужного знания. Этот поиск осуществляется  с помощью механизма унификации.

Унификация – операция, которая позволяет формализовать процесс логического вывода. С практической точки зрения  - это основной вычислительный шаг, с помощью которого происходит:
\begin{itemize}
	\item Двунаправленная передача параметров процедурам,
	\item Неразрушающее присваивание,
	\item Проверка условий (доказательство).
\end{itemize}

Упрощенно, процесс унификации можно представить как формальный процесс сравнивания (сопоставления) терма вопроса с очередным термом знания. Знания по умолчанию просматриваются сверху вниз. В процессе сравнивания для переменных «подбираются», исходя из базы знаний, значения (для именованных переменных). И эти подобранные для переменных значения возвращаются в качестве побочного эффекта ответа на поставленный вопрос.

В процессе работы система выполняет большое число унификаций.  Попытка "увидеть одинаковость" – сопоставимость двух термов, может завершаться успехом или тупиковой ситуацией (неудачей). В последнем случае включается механизм отката к предыдущему шагу.


\section*{Задание}

Составить программу – базу знаний, с помощью которой можно определить, например, множество студентов, обучающихся в одном ВУЗе. Студент может одновременно обучаться в нескольких ВУЗах. Привести примеры возможных вариантов вопросов и варианты ответов (не менее 3-х). Описать порядок формирования вариантов ответа.

\begin{lstlisting}[caption=База знаний о студентах]
domains 
	name, university, speciality, city, budget_place = string. 
	price = integer. 
predicates 
	study(name, university, speciality, budget_place). 
	locate(university, city). 
	pays(name, price). 
clauses 
	study("Ilya Ivanov", "BMSTU", "Software Engineer", "Budget"). 
	study("Ivan Petrov", "HSE", "Designer", "Paid"). 
	study("Dmitriy Vlasov", "KSU", "Historian", "Paid"). 
	study("Alexander Pushkin", "ITMO", "Software Engineer", "Budget"). 
	study("Mihail Knyazev", "BMSTU", "Mathematician", "Budget"). 
	locate("BMSTU", "Moscow"). 
	locate("HSE", "Moscow"). 
	locate("ITMO", "St-Petersburg"). 
	locate("KSU", "Krasnodar"). 
	pays(Name, 200) :- study(Name, University, _, "Paid"), locate(University, "Moscow"). 
	pays(Name, 150) :- study(Name, University, _, "Paid"), locate(University, "St-Petersburg"). 
	pays(Name, 100) :- study(Name, University, _, "Paid"), locate(University, "Krasnodar"). 
\end{lstlisting}
Данная база знаний содержит информацию о студентах(имя, вуз, специальность, основа обучения), вузах(название, город) и плате за обучение студентами(имя, сумма).

Примеры:
\begin{table}[h!] 
\begin{tabularx}{\linewidth}{|>{\centering}X|>{\centering}X|}
	\hline
	goal & Результат \tabularnewline
	\hline
	study(Name, "BMSTU", \_, \_).  & Name=Ilya Ivanov \\ 
	Name=Mihail Knyazev \\
	2 Solutions \tabularnewline
	\hline
	study(Name, University, \\ "Software Engineer"{}, \_). & Name=Ilya Ivanov, University=BMSTU \\
	Name=Alexander Pushkin, University=ITMO \\
	2 Solutions\tabularnewline
	\hline
	study(Name, University, \_, \_), locate(University, "Moscow").  & Name=Ilya Ivanov, University=BMSTU \\
	Name=Ivan Petrov, University=HSE \\
	Name=Mihail Knyazev, University=BMSTU \\
	3 Solutions\tabularnewline
	\hline
	pays(Name, Price). & Name=Ivan Petrov, Price=200 \\
	Name=Dmitriy Vlasov, Price=100 \\
	2 Solutions \tabularnewline
	\hline
\end{tabularx}
\end{table}

С помощью первого вопроса получаются все студенты , которые учатся в МГТУ. Происходит проход сверху вниз по всем фактам предиката \emph{study(name, university, speciality, budget\_place)} и осуществляется унификация с \emph{study(Name, "BMSTU"{}, \_, \_)}. Унификацию успешно проходят два факта: \emph{study("Ilya Ivanov"{}, "BMSTU"{}, "Software Engineer"{}, "Budget")} и \emph{study("Mihail Knyazev"{}, "BMSTU"{}, "Mathematician"{}, "Budget")}.

С помощью второго вопроса получаются все студенты и их вузы, которые имеют специальность программный инженер.  Происходит проход по всем фактам предиката \emph{study(name, university, speciality, budget\_place)} и осуществляется унификация с \emph{study(Name, University, "Software Engineer"{}, \_)}.  Успешно унификацию проходят факты \emph{study("Ilya Ivanov"{}, "BMSTU"{}, "Software Engineer"{}, "Budget")} и \emph{study("Alexander Pushkin"{}, "ITMO"{}, "Software Engineer"{}, "Budget")}.

С помощью третьего вопроса находятся все студенты, университеты которых расположены в Москве. Вопрос построен с помощью конъюнкции, поэтому осуществляется проход по всем фактам предиката \emph{study(name, university, speciality, budget\_place)} и предиката \emph{locate(university, city)} и осуществляется унификация с термом \emph{study(Name, University, \_, \_)}, \emph{locate(University, "Moscow")}. В результате унификацию успешно проходят: \emph{study("Ilya Ivanov"{}, "BMSTU"{}, "Software Engineer"{}, "Budget"), locate("BMSTU"{}, "Moscow")}; \emph{study("Ivan Petrov"{}, "HSE"{}, "Designer"{}, "Paid"), locate("HSE"{}, "Moscow")} и \emph{study("Mihail Knyazev"{}, "BMSTU"{}, "Mathematician"{}, "Budget"), locate("BMSTU"{}, "Moscow")}. 

С помощью последнего вопроса находятся все студенты, обучающиеся на платной основе, и их стоимость обучения. Для этого осуществляется проход по всем правилам предиката \emph{pays(name, price)} и унификация с термом \emph{pays(Name, Price)}. При унификации для каждого правила осуществляется унификация каждого терма из тела правила. Успешно унифицируются терм \emph{study("Ivan Petrov"{}, "HSE"{}, "Designer"{}, "Paid"), locate("HSE"{}, "Moscow")} с телом правила \emph{pays(Name, 200)} и терм \emph{study("Dmitriy Vlasov"{}, "KSU"{}, "Historian"{}, "Paid"), locate("KSU"{}, Krasnodar)} с телом правила \emph{pays(Name, 100)}.
\end{document}